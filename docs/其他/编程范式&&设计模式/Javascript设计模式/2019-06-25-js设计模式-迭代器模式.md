---
layout: fexo
title: "js设计模式-迭代器模式"
date: 2019-06-25T16:17:54.000Z
tags: null
permalink: 2019-06-25-iterator-pattern
---

#### 一.从一个例子开始讲起

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>迭代器模式</title>
  </head>
  <body>
    <p>jquery each</p>
    <p>jquery each</p>
    <p>jquery each</p>

    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <script>
      var arr = [1, 2, 3];
      var nodeList = document.getElementsByTagName("p");
      var $p = $("p");
      // 第一
      arr.forEach(function(item) {
        console.log(item);
      });
      // 第二
      var i,
        length = nodeList.length;
      for (i = 0; i < length; i++) {
        console.log(nodeList[i]);
      }
      // 第三
      $p.each(function(key, p) {
        console.log(key, p);
      });
    </script>
  </body>
</html>
```

可以看到的时候上面有三种不同的数据结构,他们都有顺序遍历的需求,但是由于 api 不同,我们得写多种遍历的方式,而**迭代器模式就是为了简化有序集合的遍历**产生的模式
我们可以用 jquery 的 each 方法来对上面的几种遍历的方式进行统一的封装

```js
function each(data) {
  var $data = $(data);
  $data.each(function(key, p) {
    console.log(key, p);
  });
}
each(arr);
each(nodeList);
each($p);
```

结果如下

#### 二.迭代器模式

##### 1.UML 类图:

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190124154200726.png)
我们的 **Container** 类接受一个有序的数据结构,它有个 **getIterator** 方法,返回一个迭代器,迭代器中右一个 **hasNext** 方法来判断是否能够继续迭代,next 方法返回迭代的结果

##### 2.代码实现

```js
class Container {
  constructor(list) {
    this.list = list;
  }
  getIterator() {
    return new Iterator(this.list);
  }
}

class Iterator {
  constructor(list) {
    this.list = list;
    this.index = 0;
  }
  next() {
    if (this.hasNext()) {
      return this.list[this.index++];
    }
    return null;
  }
  hasNext() {
    if (this.index >= this.list.length) {
      return false;
    }
    return true;
  }
}
//测试
let arr = [1, 2, 3, 4, 5, 6];
let container = new Container(arr);
let iterator = container.getIterator();
while (iterator.hasNext()) {
  console.log(iterator.next());
}
```

结果如下

```bash
1
2
3
4
5
6
[ 'a', 100 ]
[ 'b', 200 ]

```

#### 三.ES6 中的迭代器

众所周知,ES6 中出现了迭代器 iterator,但是好像我们工作中没怎么用到?它究竟是怎么一回事呢?

##### 1.为什么 ES6 中会出现迭代器

主要原因是在 ES6 中,有序的数据集合已经很多了,

> Array, Map, Set, String, TypeArray, arguments, NodeList

因此需要一个迭代器提供统一接口,来对这些数据的遍历进行简化

##### 2.ES6 中的 Iterator 究竟是什么?

ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是“可遍历的”（iterable.Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。我们可以使用 Array 来进行演示

```js
Array.prototype[Symbol.iterator]
> ƒ values() { [native code] }
Array.prototype[Symbol.iterator]()
> Array Iterator {}
Array.prototype[Symbol.iterator]().next()
> {value: undefined, done: true}
```

ES6 中的 iterator 和我们上面的大同小异,无非是将 next 方法和 hasNext 进行了合并而已.下面我们通过 ES6 提供的 iterator 接口来重构上面的 each 函数

```js
function each(data, callback) {
  //通过js提供的Symbol.iterator返回迭代器
  const iterator = data[Symbol.iterator]();
  let item = { done: false };
  while (!item.done) {
    item.iterator.next();
    if (!item.done) {
      callback(item);
    }
  }
}
let log = data => {
  console.log(data);
};

let arr = [1, 2, 3, 4, 5, 6];
let map = new Map();
map.set("a", 100);
map.set("b", 200);

each(arr);
each(map);
```

结果和未修改前的 each 方法一样

##### 3.for .... of

为了让调用进一步简化,而不是每一位开发者都得实现类似上面的 each 方法, ES6 提供了 for...of 语法糖,
上面的 each 方法实际上等价于

```js
for (let item of data) {
  cb(item);
}
```

#### 四.iterator 和 generator

Iterator 的价值不仅仅局限于上述几个数据结构的遍历,还可以结合 Generator 解决异步的问题

```js
function* gen() {
  yield "1";
  yield "2";
  return "done";
}
var g = gen();
g[Symbol.iterator];
```

> ƒ [Symbol.iterator]() { [native code] }
>
> 可以看到,generator 函数可提供了 Symbol.iterator 接口
> generator 函数在 koa1 中是结合 co 库来大规模使用的,但是 koa2 中已经使用了新的语法特性 async 函数进行了替代, 但是有时为了维护老项目,我们还是得理解.

参考资料
https://coding.imooc.com/class/chapter/255.html#Anchor
http://es6.ruanyifeng.com/#docs/iterator
