(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{256:function(t,r,a){"use strict";a.r(r);var v=a(2),s=Object(v.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("资料来源\nhttps://www.angularjs.net.cn/tutorial/22.html")]),t._v(" "),a("h2",{attrs:{id:"scope"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scope"}},[t._v("#")]),t._v(" scope")]),t._v(" "),a("p",[t._v("作用域作为数据模型使用\n其实可以很简单地理解为有以下两个链条关系：")]),t._v(" "),a("p",[t._v("控制器 --\x3e 作用域 --\x3e 视图（DOM）\n指令 --\x3e 作用域 --\x3e 视图（DOM）")]),t._v(" "),a("h2",{attrs:{id:"provider"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#provider"}},[t._v("#")]),t._v(" provider")]),t._v(" "),a("p",[t._v("注入器创建两类对象，服务和专用对象。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("服务是对象，而这些对象的 API 是由编写服务的开发人员所决定的。")])]),t._v(" "),a("li",[a("p",[t._v("专用对象遵循 Angular 框架特定的 API。这些对象包括"),a("strong",[t._v("控制器，指令，过滤器或动画")]),t._v("。")])])]),t._v(" "),a("p",[t._v("注入器需要知道如何去创建这些对象。你应该通过注册一种“图纸”来告诉 Angular 如何创建你的对象。这里共有 5 种图纸")]),t._v(" "),a("p",[t._v("Provider 图纸，其余 4 种分别是 —— Value，Factory，Service 和 Constant，这 4 种都只是基于 Provider 之上的语法糖。")]),t._v(" "),a("h4",{attrs:{id:"关于模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于模块"}},[t._v("#")]),t._v(" 关于模块")]),t._v(" "),a("p",[t._v("为了使注入器知道如何创建这些对象，并让它们能绑定在一起协同工作，我们需要一张关于“图纸”的注册表。每个图纸都有对象的识别码以及如何创建该对象的说明。")]),t._v(" "),a("p",[t._v("每个图纸都属于一个 Angular 模块。一个 Angular 模块就像是装着一张或多张图纸的袋子。通过手工记录模块依赖关系是很无趣的工作，所以一个模块里也应该包含该模块依赖于哪些其他模块的信息。")]),t._v(" "),a("p",[a("strong",[t._v("当基于 Angular 的应用从一个指定的应用模块启动时，Angular 会创建一个注入器的实例，紧接着该注入器实例就会创建一张包含“图纸”的注册表，这张注册表就是由 Angular 核心模块、应用模块以及应用模块的依赖里面定义的所有图纸的集合。当注入器需要为你的应用创建一个对象时，注入器就会查询这张注册表")]),t._v("。(injector 中的 cache)")]),t._v(" "),a("h4",{attrs:{id:"constant-图纸"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constant-图纸"}},[t._v("#")]),t._v(" constant 图纸")]),t._v(" "),a("p",[t._v("既然简单的值，例如 url 前缀，并不依赖其他服务或配置，那么使他们在配置和运行阶段都可访问的话，就可以让我们更得心应手一些。这就是 Constant 图纸存在的意义。")]),t._v(" "),a("h2",{attrs:{id:"location-服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#location-服务"}},[t._v("#")]),t._v(" $location 服务")]),t._v(" "),a("p",[t._v("负责解析地址栏中的 url, 类比 react-router, vue-router")]),t._v(" "),a("p",[t._v("$location 服务有两种配置模式，它将控制浏览器地址栏中的地址显示格式：Hashbang 模式（默认）和 HTML5 模式")]),t._v(" "),a("h2",{attrs:{id:"单元测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单元测试"}},[t._v("#")]),t._v(" 单元测试")]),t._v(" "),a("p",[t._v("单元测试，顾名思义就是用于测试代码中不可分割的单元。单元测试试图回答下列问题：“我所认为的逻辑正确吗？”或者“我的 sort 函数是否按照正确的顺序排序了这个列表？”")]),t._v(" "),a("p",[t._v("最重要的事情就是：我们要能把这个单元的代码隔离到一个独立的 test 模块中。 这是因为我们测试 sort 函数的时候，绝不会希望也被迫创建相关的部分 —— 比如 DOM 元素，或者先发起一个 XHR 调用来获取完数据才能测试 sort 函数，一个典型的项目中，想要调用一个独立函数确实是非常困难的。 原因在于，开发人员经常会把不同的任务揉成一团，导致一部分代码中往往会做很多很多事：发起 XHR 请求，对返回的数据进行排序，然后更新到 DOM。")]),t._v(" "),a("p",[t._v("angualr 做了两件事")]),t._v(" "),a("ul",[a("li",[t._v("依赖注入")]),t._v(" "),a("li",[t._v("建立抽象层， 如 controller 层， filter 层， directive 层")])]),t._v(" "),a("h2",{attrs:{id:"端对端测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#端对端测试"}},[t._v("#")]),t._v(" 端对端测试")]),t._v(" "),a("p",[t._v("介绍了 angular 自己的测试框架， protractor")])])}),[],!1,null,null,null);r.default=s.exports}}]);